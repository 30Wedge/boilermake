# OBJS eventually gets built-up to include all object files in the entire
# project hierarchy. It MUST start out empty.
OBJS :=

# DIRS eventually gets built-up to include all sub-directories in the entire
# project hierarchy. It MUST start out empty.
DIRS :=

# Include the main module makefile fragment. This also will recrusively include
# all sub-module makefile fragments.
include module.mk

# Make sure the final executable goes into the top-level output directory if
# one was specified.
OUT := $(patsubst %,${OUTDIR}%,${OUT})

# Rule to build the final executable.
${OUT}: ${OBJS}
	${CXX} -o ${OUT} ${CXXFLAGS} ${OBJS}

# Pattern rule to build object files from C++ files. This also auto-generates
# dependency files (*.P) as part of the compilation step. The dependency files
# will then be included in the make file (see below) on the next invocation
# of make.
${OUTDIR}%.o: %.cc
	@mkdir -p $(dir $@)
	${CXX} -c -MD -o $@ ${TGT_CXXFLAGS} ${CXXFLAGS} ${TGT_INCDIRS} $<
	@cp ${OUTDIR}$*.d ${OUTDIR}$*.P; \
	sed -e 's/#.*//' -e 's/^[^:]*: *//' -e 's/ *\\$$//' \
	    -e '/^$$/ d' -e 's/$$/ :/' < ${OUTDIR}$*.d >> ${OUTDIR}$*.P; \
	rm -f ${OUTDIR}$*.d

# The list of dependency files is generated based on the list of object files.
# Then the dependency files (which were autogenerated during the preceding
# invocation of make) are included. Note that some or all of the dependency
# files might not exist, hence the use of "-" before "include".
P_INCLUDES := $(patsubst %.o,%.P,${OBJS})
-include ${P_INCLUDES}

# Rule to clean everthing.
.PHONY: clean
clean:
	rm -f ${OUT} ${OBJS} ${P_INCLUDES}
